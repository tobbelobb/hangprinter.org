#usda 1.0
(
    doc = "A better USD scene for Flipper cable demo"
    metersPerUnit = 1
    startTimeCode = 0
    timeCodesPerSecond = 500
    upAxis = "Y"
)
def Xform "World"
{
    def Xform "FlipperScene"
    {
        def Sphere "Ball1" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "PhysicsMassAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Ball"]
            rel material:binding = </World/PhysicsScene/BallMaterial>
            custom bool cable:linkable = 1
            double radius = 0.04
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.9, 0.95, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
            float physics:mass = 0.0028274333882308137
            float3 physics:angularVelocity = (0, 0, 0)
            matrix3d physics:inertiaTensor = ((1.272345024703866e-06, 0, 0), (0, 1.272345024703866e-06, 0), (0, 0, 1.272345024703866e-06))
        }

        def Sphere "Ball2" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "PhysicsMassAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Ball"]
            rel material:binding = </World/PhysicsScene/BallMaterial>
            custom bool cable:linkable = 1
            double radius = 0.03
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.08, 0.5, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
            float physics:mass = 0.0028274333882308137
            float3 physics:angularVelocity = (0, 0, 0)
            matrix3d physics:inertiaTensor = ((1.272345024703866e-06, 0, 0), (0, 1.272345024703866e-06, 0), (0, 0, 1.272345024703866e-06))
        }

        def Sphere "Obs1" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Obstacle"]
            bool physics:rigidBodyEnabled = 0
            custom float obstacle:pushVel = 2.7
            rel material:binding = </World/PhysicsScene/ObstacleMaterialBlue>
            double radius = 0.1
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.25, 0.6, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
        }

        def Sphere "Obs2" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Obstacle"]
            bool physics:rigidBodyEnabled = 0
            custom float obstacle:pushVel = 2.7
            rel material:binding = </World/PhysicsScene/ObstacleMaterialBlue>
            double radius = 0.1
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.75, 0.5, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
        }

        def Sphere "Obs3" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "PhysicsMassAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Obstacle"]
            rel material:binding = </World/PhysicsScene/ObstacleMaterialOrange>
            custom bool cable:linkable = 1
            custom float obstacle:pushVel = 2.7
            double radius = 0.12
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.7, 1, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
            float3 physics:angularVelocity = (0, 0, 5729.5779513082325)
            matrix3d physics:inertiaTensor = ((0.000288, 0, 0), (0, 0.000288, 0), (0, 0, 0.000288))
        }

        def Sphere "Obs4" (
            apiSchemas = ["PhysicsCollisionAPI", "PhysicsRigidBodyAPI", "PhysicsMassAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Obstacle"]
            rel material:binding = </World/PhysicsScene/ObstacleMaterialOrange>
            custom bool cable:linkable = 1
            custom float obstacle:pushVel = 2.7
            double radius = 0.1
            quatf xformOp:orient = (1, 0, 0, 0)
            double3 xformOp:translate = (0.2, 1.2, 0)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]
            float3 physics:angularVelocity = (0, 0, -5729.5779513082325)
            matrix3d physics:inertiaTensor = ((0.00020000000000000004, 0, 0), (0, 0.00020000000000000004, 0), (0, 0, 0.00020000000000000004))
        }

        def Xform "CablePath" (
            apiSchemas = ["CablePathAPI"]
        )
        {
            custom bool[] cablePath:clockwise = [1, 1, 1, 1]
            custom bool cablePath:enabled = 1
            custom rel cablePath:joints = [
                </World/FlipperScene/Joint1>,
                </World/FlipperScene/Joint2>,
                </World/FlipperScene/Joint3>,
            ]
            custom token[] cablePath:linkTypes = ["hybrid-attachment", "rolling", "rolling", "hybrid-attachment"]
            custom double[] cablePath:stored = [0, 0.18856494486496805, 0.06274932338455928, 0]
            custom double cablePath:totalLength = 1.600225609524756
            custom double stiffness = 200
        }

        def CableJoint "Joint1"
        {
            # TODO: The localPos attributes on CableJoints are likely misnamed and contain world coordinates.
            custom bool enabled = 1
            custom point3d localPos0 = (0.08085505352834965, 0.5299878122487063, 0)
            custom point3d localPos1 = (0.10004062583764584, 1.202850178427832, 0)
            custom rel physics:body0 = </World/FlipperScene/Ball2>
            custom rel physics:body1 = </World/FlipperScene/Obs4>
            custom double restLength = 0.6731358332498777
        }

        def CableJoint "Joint2"
        {
            custom bool enabled = 1
            custom point3d localPos0 = (0.23366516978503094, 1.2941629244625772, 0)
            custom point3d localPos1 = (0.740398203742037, 1.1129955093550927, 0)
            custom rel physics:body0 = </World/FlipperScene/Obs4>
            custom rel physics:body1 = </World/FlipperScene/Obs3>
            custom double restLength = 0.5381449618829482
        }

        def CableJoint "Joint3"
        {
            custom bool enabled = 1
            custom point3d localPos0 = (0.7914301947495155, 1.0777207789980623, 0)
            custom point3d localPos1 = (0.8805698052504844, 0.9728575486873788, 0)
            custom rel physics:body0 = </World/FlipperScene/Obs3>
            custom rel physics:body1 = </World/FlipperScene/Ball1>
            custom double restLength = 0.1376305461424022
        }

        def PhysicsRevoluteJoint "FixedObs3"
        {
            rel physics:body1 = </World/FlipperScene/Obs3>
            point3f physics:localPos0 = (0.7, 1, 0)
            point3f physics:localPos1 = (0, 0, 0)
            quatf physics:localRot0 = (1, 0, 0, 0)
            quatf physics:localRot1 = (1, 0, 0, 0)
            token physics:axis = "Z"
        }

        def PhysicsRevoluteJoint "FixedObs4"
        {
            rel physics:body1 = </World/FlipperScene/Obs4>
            point3f physics:localPos0 = (0.2, 1.2, 0)
            point3f physics:localPos1 = (0, 0, 0)
            quatf physics:localRot0 = (1, 0, 0, 0)
            quatf physics:localRot1 = (1, 0, 0, 0)
            token physics:axis = "Z"
        }

        def Xform "Flipper1" (
            apiSchemas = ["PhysicsRigidBodyAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Flipper"]
            rel material:binding = </World/PhysicsScene/FlipperMaterial>
            bool physics:kinematicEnabled = 1
            custom bool cable:linkable = 1
            custom float flipper:angularVelocity = 20
            custom float flipper:length = 0.2
            custom float flipper:maxRotation = 1
            custom float flipper:restAngle = -0.5
            double3 xformOp:translate = (0.26, 0.22, 0)
            quatf xformOp:orient = (0.9689124, 0, 0, -0.247404)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]

            def Capsule "Geom" (
                apiSchemas = ["PhysicsCollisionAPI"]
            )
            {
                double radius = 0.03
                double height = 0.2
                token axis = "X"
                double3 xformOp:translate = (0.1, 0, 0)
                uniform token[] xformOpOrder = ["xformOp:translate"]
            }

            def Xform "Tip"
            {
                custom bool cable:linkable = 1
                double3 xformOp:translate = (0.2, 0, 0)
                uniform token[] xformOpOrder = ["xformOp:translate"]
            }
        }

        def Xform "Flipper2" (
            apiSchemas = ["PhysicsRigidBodyAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Flipper"]
            rel material:binding = </World/PhysicsScene/FlipperMaterial>
            bool physics:kinematicEnabled = 1
            custom bool cable:linkable = 1
            custom float flipper:angularVelocity = 20
            custom float flipper:length = 0.2
            custom float flipper:maxRotation = -1
            custom float flipper:restAngle = 3.6415927
            double3 xformOp:translate = (0.74, 0.22, 0)
            quatf xformOp:orient = (-0.247404, 0, 0, 0.9689124)
            uniform token[] xformOpOrder = ["xformOp:translate", "xformOp:orient"]

            def Capsule "Geom" (
                apiSchemas = ["PhysicsCollisionAPI"]
            )
            {
                double radius = 0.03
                double height = 0.2
                token axis = "X"
                double3 xformOp:translate = (0.1, 0, 0)
                uniform token[] xformOpOrder = ["xformOp:translate"]
            }

            def Xform "Tip"
            {
                custom bool cable:linkable = 1
                double3 xformOp:translate = (0.2, 0, 0)
                uniform token[] xformOpOrder = ["xformOp:translate"]
            }
        }

        def Mesh "Border" (
            apiSchemas = ["PhysicsCollisionAPI", "MaterialBindingAPI"]
        )
        {
            token[] ecs:tags = ["Border"]
            rel material:binding = </World/PhysicsScene/BorderMaterial>
            point3f[] points = [
                (0.74, 0.0, 0.0), (0.74, 0.25, 0.0), (0.98, 0.4, 0.0), (0.98, 1.68, 0.0),
                (0.02, 1.68, 0.0), (0.02, 0.4, 0.0), (0.26, 0.25, 0.0), (0.26, 0.0, 0.0),
                (0.74, 0.0, 0.1), (0.74, 0.25, 0.1), (0.98, 0.4, 0.1), (0.98, 1.68, 0.1),
                (0.02, 1.68, 0.1), (0.02, 0.4, 0.1), (0.26, 0.25, 0.1), (0.26, 0.0, 0.1)
            ]
            int[] faceVertexCounts = [4, 4, 4, 4, 4, 4, 4, 4]
            int[] faceVertexIndices = [
                0, 1, 9, 8, 1, 2, 10, 9, 2, 3, 11, 10, 3, 4, 12, 11,
                4, 5, 13, 12, 5, 6, 14, 13, 6, 7, 15, 14, 7, 0, 8, 15
            ]
            uniform token subdivisionScheme = "none"
        }
    }

    def PhysicsScene "PhysicsScene"
    {
        vector3f physics:gravityDirection = (0, -1, 0)
        float physics:gravityMagnitude = 2.00
        def Material "BallMaterial" (
            prepend apiSchemas = ["PhysicsMaterialAPI", "PhysxMaterialAPI"]
        )
        {
            def Shader "Shader"
            {
                color3f inputs:diffuseColor = (0.62745, 0.62745, 0.62745)
            }
            float physics:staticFriction = 0.2
            float physics:dynamicFriction = 0.2
            float physics:restitution = 0.6
        }

        def Material "ObstacleMaterialOrange" (
            prepend apiSchemas = ["PhysicsMaterialAPI", "PhysxMaterialAPI"]
        )
        {
            def Shader "Shader"
            {
                color3f inputs:diffuseColor = (1.0, 0.5, 0)
            }
            float physics:staticFriction = 0.2
            float physics:dynamicFriction = 0.2
        }

        def Material "ObstacleMaterialBlue" (
            prepend apiSchemas = ["PhysicsMaterialAPI", "PhysxMaterialAPI"]
        )
        {
            def Shader "Shader"
            {
                color3f inputs:diffuseColor = (0.059, 0.439, 0.565)
            }
            float physics:staticFriction = 0.2
            float physics:dynamicFriction = 0.2
        }

        def Material "FlipperMaterial" (
            prepend apiSchemas = ["PhysicsMaterialAPI", "PhysxMaterialAPI"]
        )
        {
            def Shader "Shader"
            {
                color3f inputs:diffuseColor = (1.0, 0, 0)
            }
            float physics:staticFriction = 0.01
            float physics:dynamicFriction = 0.01
            float physics:restitution = 0.6
        }

        def Material "BorderMaterial" (
            prepend apiSchemas = ["PhysicsMaterialAPI", "PhysxMaterialAPI"]
        )
        {
            def Shader "Shader"
            {
                color3f inputs:diffuseColor = (0, 0, 0)
            }
        }
    }
}
